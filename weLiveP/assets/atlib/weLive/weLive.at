import /.weLive.weLiveLocalInterface;
import /.weLive.weLiveRemoteInterface;
import /.at.support.timer;

import /.at.lang.futures exclude minutes, seconds, millisec;
enableFutures(true);
//paksos senses alghorythm for leader

//Defain Player
deftype Player;
 
def log(text) {
  Android.Log.v("weLive", text);
};

// WPO session 6 slide 15
//Create Android object
// Android := object: {
//	def parent := jlobby.edu.vub.at.android.util.IATAndroid.getInstance().getParentActivity();
//	def Log := jlobby.android.util.Log;
//};


//Main function also define myUserID that is random number
def makeWeLive(){
	object:{
		//define object to talk with JAVA
		def JweLive;

  		//HashMap of [userId, Far Reference]
		def users := jlobby.java.util.HashMap.new();
		//Array of far references, avoids iterating over hashmap
		def userReferences := [];
		def userIds := [];
		
  		//myUserId definition from localinterface (set by JAVA)
		def myUserId;
		// My user path
		def myUserPath := self;

		//define coordinator reference
		def coordinatorRef;
		def coordinatorId;
  		
	  	// HashMap of [userId, point(x,y)];
	  	def points := jlobby.java.util.HashMap.new();

		//def points.each: closure {
		//    def valit := points.values().iterator();
		 //   while: { valit.hasNext() } do: {
		 //     closure(valit.next());
		//    };
	  //	};
	  	

		//Local interface for android gui
		def local := weLiveLocalInterface.new(self);
		//Remote interface for other AT actors
		def remote := weLiveRemoteInterface.new(self);
	  


	  
	  export: remote as: Player;
	  whenever: Player discovered: { |ref|
	    log("Discovered other painter:" + ref);

	
	 def knownUser := userReferences.contains(ref);
	    if: (! knownUser) then: {
	
		      // ask user id to be able to grey out/recolor upon disconnection.
		      when: ref<-getUserId()@FutureMessage becomes: { | id |
		        system.println("Discovered other player:" +id + " : " +ref);
				
				//Store ref into ref array
				 userReferences := userReferences + [ref];
				 userIds := userIds + [id];
				 //store ref and id in users hash map
				 users.put(id, ref);
				
					
				//If my coordinator is nil and I discover new player I ask him: what is yours Coordinator ref
				 if: (self.coordinatorRef == nil) then:{
				    when: ref<-getCoordinator()@FutureMessage becomes:{ |coordinator|
				    	
				    	def cooId := coordinator;
				    	
				    	if: (cooId != nil) then: {
				    		// get ref for coordinator
				    		def othRef := users.get(cooId);
				    		
				    		
				    		self.coordinatorId := cooId;
				    		self.coordinatorRef := othRef;
				    		system.println("Coordinator set to: " + self.coordinatorRef);
				    	};
		
				    	if: (self.coordinatorRef == nil) then:{
					   		//self.coordinatorRef := myUserPath;
					   		//self.coordinatorId := myUserId;
				    		//system.println("Coordinator is ME = " + self.coordinatorRef);
				    		
				    		//Start Fight for coordinator roles
							coordinatorFight();
				    		
					    };  	
				    };
				};
				
		        whenever: ref disconnected: {
		          system.println("Disconnected other player:" +id + " : " +ref);
		          system.println("CoordinatorID = " + coordinatorId);
			          if: (id == coordinatorId) then: {
			          		//do coordinator selection
							system.println("Coordinator Disconnected. Chose new one");
							coordinatorFight();
			          };
		        };
		
		        whenever: ref reconnected: {
		          system.println("Reconnected other player:" +id + " : " +ref);
		        };			 	      
		      
		      };
	    
	    };
  
	    
	  };

	 
	 
	//If no player is discovered in 20 sec -> I set myself as coordinator
	//till moment when I discover sombody
	  when: seconds(30) elapsed: {
	  
	  		if: (userReferences.length < 1) then: {
	  			system.println("I did not discover anybody in 30 sec, I am setting myself as coordinator");
		  		self.coordinatorRef := myUserPath;
				self.coordinatorId := myUserId;
	  		}
	  		else: {
	  			system.println("I discover somebody in 30 sec and 1 - he give me coordinator or we fait who will be the one");
	  		};
	  };
	 
	 
	 
	//Coordinator Fight function
	def coordinatorFight(){
		system.println("Coordinator Fight");
	
		def bigUserRef := [];
		userIds.each: { |bigUserID|
		
			if: (bigUserID > self.myUserId) then:{
				//get reference
				def othRef := users.get(bigUserID);
				//put references into list
				bigUserRef := bigUserRef + [othRef];			
				
			};
		}; //end of each userIds

		
		if: (bigUserRef == []) then:{
			
		};
		//if bigUserRef is empty I might be coordinator
 		system.println("BigUserRef list lenght" + bigUserRef.length);
		
		
		
		bigUserRef.each: { |othRef|
			//def msg := <-areYouLive();
			//when: othRef<-areYouLive()@Due(1.minutes) becomes: { | answId |
			when: othRef<-areYouLive()@FutureMessage becomes: { | answId |
				system.println("User is livee");
				//Do nothing becouse, someone bigger than me is alive
			} catch: TimeoutException using: { |e|
			 	 // user did not responde in 20 sec -> he is dead
				system.println("User is deadd");
				
				//count how many I had bigUserRef and how many dead users I have
				//if they the count is the same -> I become as coordinator
				
				//If noone greater is live
				//I set myself as coordinator
				//weLiveParent.coordinatorId := weLiveParent.myUserId;
				//weLiveParent.coordinatorRef := weLiveParent.myUserPath;
			};
			
				system.println("Test");
				//test
				//def chechDue := othRef<-ch()@Due(minutes(1));
				when: othRef<-ch()@Due(minutes(1)) becomes: { |message|
					system.println("Yes");
				}
				catch: TimeoutException using: { |e|
					system.println("NO");
				};
			
		};
		
	};
	 
	JweLive := Android.parent.registerATApp(local);
	};
};

system.println("weLive started");
network.online();
self;